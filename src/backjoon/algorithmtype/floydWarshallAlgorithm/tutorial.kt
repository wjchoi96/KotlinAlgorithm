/*
    바킹독님 알고리즘 강의 중 플로이드-워셜 알고리즘 단원
    https://blog.encrypted.gg/1035

    최단경로 알고리즘

    #플로이드 알고리즘이란
    그래프에서 모든 정점 쌍 사이의 최단거리를 구해주는 알고리즘
    - 그래프가 방향이건 무방향이건 상관없음
    - 간선의 값이 음수여도 동작하지만, 음수인 사이클이 있으면 문제가 발생(흔한 상황은 아님)

    #플로이드 알고리즘의 구현
    일반적인 인접행렬 방식으로 다른 정점을 거쳐가지 않을때의 최단거리 테이블을 작성 가능

    해당 테이블에서 s에서 t정점으로 갈때, 1번 정점을 거쳐간다면
    - D[s][1] + D[1][t]가 최단거리
    - s에서 1까지 최단경로로 가고, 1에서 t까지 최단경로로 진행했을때의 값
    - D[s][t]보다 D[s][1] + D[1][t]가 작을 경우(=직접가는것보다, 1번정점을 거쳐가는게 효율적인 경우)
    에 D[s][t]를 갱신해주면 됨

    해당 테이블에서 s에서 t정점으로 갈때, 2번 정점을 거친다면?
    - 위와 비슷

    본래 테이블에서 각 정점을 거쳐서 갈때의 최단거리로 차츰차츰 업데이트 해주면 됨
    => 정점이 V개라면 총 V단계에 거쳐서 갱신이 이루어짐
    => 각 단계마다 총 V^2개의 모든 D[s][t]값을 D[s][k] + D[k][t]값과 비교
    => 플로이드 알고리즘의 총 시간복잡도는 O(V^3)
    => 삼중 for문

    #경로 복원
    1. a에서 b까지 최단거리로 가려면, a에서 어느정점으로 가야하는지 알아내야 함
    - nxt 테이블
    - nxt 테이블은 최단거리테이블을 채우는 과정에 같이 채워지게 됨
    - nxt 테이블은, A에서 B정점으로 가려면 어느 정점을 가야하는지에 대한 정보(비용이 아님)

    2. 최단거리 테이블을 채우며 D[i][j]와 D[i][k] + D[k][j]를 비교할때, 더 가까운 거리가 생긴다면
    nxt테이블을 갱신
    - 기존경로보다 더 효율적인 경로가 나왔으니 갱신
    예) 1에서 2를가는 상황 => nxt[1][2] = 2였던 상황
    D[1][2] 보다 D[1][3] + D[3][2]가 더 값이 작다면 nxt[1][2] = 3으로 갱신이됨
    => 1에서 2로 갈때, 곧바로 2로 가는것보다 3번을 거쳐가는게 더 효율적이기 때문

    3. nxt테이블을 보고 경로를 복원
    추측) 
    nxt[3][5] = 1
    nxt[1][5] = 4
    nxt[4][5] = 5 
    인 상황에서, 3에서 5로 가는 경로는?
    3 -> 1 -> 4 -> 5
    nxt 테이블을 따라 탐색해나가면 될것 같음

    풀이)
    추측과 일치

    #플로이드 알고리즘의 적용
    - 무방향, 방향 그래프에서 모든 정점 쌍 사이의 최단거리를 O(V^3)에 알아낼 수 있음
    - 그래프의 정점의 수가 1000개 이하라면, 플로이드 알고리즘을 적용 가능함을 인지
    - 플로이드 알고리즘의 원리 자체를 이해하고 있어야 하는 응용문제들이 많음


    #연습문제
    1. 백준 11404(solve)
    2. 백준 11780(solve)
    - 경로 복원 포함

*/