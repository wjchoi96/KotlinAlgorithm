/*
    바킹독님 알고리즘 강의 중 이진검색트리 단원
    https://blog.encrypted.gg/1013

    ===================================================================
    #시작 전 특이사항
    특이하게도, 이번 단원은 구현을 직접 하지 않는다
    이진검색트리는 자가균형트리라는것을 적용하지 않으면 시간복잡도가 좋지 않아서 사용하기 
    걸맞지 않다.
    문제는 자가균형트리는 구현 난이도가 무척(헬) 높아서 실제 코딩테스트에서 구현하는것은 불가능에 가깝다

    STL(C++의 경우)을 사용하여 풀이하고, STL을 쓸 수 없는 환경에서 이진검색트리를 사용하고 싶다면
    이진검색트리를 사용하지 않는 풀이를 찾아내는 것을 추천한다
    어찌 이진검색트리를 구현한다 해도, 자가균형트리 없이는 높은 확률로 시간초과가 발생할 것
    어떻게든 해시나 이분탐색 같은 다른 방법을 사용하는 풀이를 고민해야 한다

    ===================================================================
    #트리
    해당 강의 기준으로 트리는 아직 학습을 하지 않았기에, 계층 구조를 가지고,
    제일 꼭대기를 제외하고 각 동그라미들은 위로 딱 1개와 연결이 되어있는 녀석이라고 기억하고 넘어가자

    -정점, 노드
    트리에서의 각 원소

    -루트
    제일 꼭대기에 위치한 정점

    -리프
    제일 말단에 위치해 아래로 뻗은게 없는 정점

    -간선
    정점을 연결하는 선
    간선으로 이루어진 위, 아래의 관계를 부모 자식 관계라 칭한다

    -서브트리
    어느 한 정점에 대해 그 밑에있는 정점과 간선만을 모은 트리를 서브트리 라고 한다

    -높이
    트리의 높이는 위 아래로 뻗어있는 정도를 나타낸다
    노드가 1개만 있을때 높이를 1로 두느냐 0으로 두느냐 나뉠 수 있다

    ===================================================================
    #이진트리
    각 노드의 자식이 2개 이하인 트리
    자식이 2개 이하이기 때문에 왼쪽 자식, 오른쪽 자식으로 구분 가능


    ===================================================================
    #이진검색트리(Binary Search Tree / BST)
    왼쪽 서브트리의 모든 값은 부모의 값보다 작고, 
    오른쪽 서브트리의 모든 값은 부모의 값보다 큰 이진 트리

    inster, erase, find, update -> O(lg N)
    원소가 크기 순으로 정렬되어 있음

    *배열과의 차이점
    배열은 erase같은 연산은 배열 중간에 있는 원소 제거를 위해서는 O(N)이 소모되며, find, update 모두 O(n)이다
    이진 검색트리는 inster, erase, find, update가 모두 O(lg N)이니 해당 작업들이 빈번할 경우 사용하면 좋다

    *해시와의 차이점
    해시는 inster, erase, find, update가 모두 O(1)이지만, 이진검색트리는 원소가 크기 순으로 정렬된다는 강력한 특징이 존재
    
    #inster, erase, find, update가 빈번하며, 원소의 대소와 관련된 성질이 필요한 경우 이진검색트리를 시용하면 좋자

    [insert], [find]의 경우
    해당 값의 자리를 찾을때까지 현재 노드와의 대소 관계를 고려하여 왼쪽, 오른쪽으로 이동

    [erase]
    1. 자식이 없는 정점을 지울때
    :그냥 제거해도 트리 구조가 망가지지 않는다

    2. 자식이 있는 정점을 지울때
    -> 무턱대고 지운다면 트리 구조가 망가진다

    2-1. 자식이 1개인 정점을 지울때
    :현재 정점을 지우고, 자식노드를 지워진 자리에 넣는다

    2-2. 자식이 2개인 정점을 지울때
    :현재 노드를 지우고, 현재 노드보다 큰 노드 중 가장 작은 노드를 찾아 지워진 자리에 넣는다
    그리고 해당 노드의 경우는 <2-1>자식이 1개인 정점을 지울때 의 과정을 거친다
    ==> 해당 노드는 무조건 자식이 없거나 하나일것. 그렇지 않으면 지워진 노드보다 큰 노드중 가장 작은 노드가 될 수 없다
    (자식이 2개라는것은, 자기 자신보다 작은 노드, 큰노드가 하나씩 연결되어 있다는 의미이기 때문)

    [insert], [find], [erase] 세 연산은 트리의 높이가 얼마인지에 따라 시간복잡도가 정해진다

    - 각 정점이 대부분 자식을 2개씩 가지고 있는 경우 
    높이가 하나씩 내려갈때마다 자식의 수가 1,2,4,8.. 이렇게 2배씩 증가하기 때문에 정점이 n개 있다면 높이는 lg N 이다
    해당 경우는 시간복잡도가 O(lg N)

    - 트리가 한쪽으로 편향되어있다면 예)[1-루트(2)-3-4-5-6-7]
    높이가 O(N)에 가깝기때문에 시간복잡도가 O(N)
    inster, erase, find, update을 O(lg N)에 사용하려고 이진검색트리를 사용하는데, 트리가 이런 형태라면 그냥
    LinkedList를 사용하는것과 차이가 전혀 없다
    [1,2,3,4] 같은 데이터를 크키 순으로 원소를 삽입한다면 1이 루트가 되고, 오른쪽에 일직선으로 연결되는 편향된 트리가 만들어진다(이러한 경우가 생각보다 잦다)
    이를 해결해 주는 것이 자가 균형 트리

    ===================================================================
    #자가-균형트리(Self-Balancing Tree)
    대표적으로 AVL트리, Red Black 트리가 있다
    구현은 AVL이 좀 더 쉽지만, 성능은 Red Black트리가 더 좋다

    간단한 원리는 한쪽으로 편향된 불균형이 발생할때, 트리를 꺾어 버린다
    예) 45(루트)-55-60 -> 45-55(루트)-60

    구현은 너무 까다로워서 생략
    이렇게 편향성을 해소해주는 자가 균형 트리를 사용할때, 비로소 이진 검색 트리에서 삽입, 검색, 삭제가 모두 O(lg N)이 된다

    ===================================================================
    자가-균형 트리로 구현된 Kotlin Collection
    #TreeMap: RB Tree를 사용한 Map
    <https://medium.com/depayse/kotlin-collections-2-map-hashmap-treemap-linkedhashmap-76195842f0c8>
    Tree 구조이기 때문에 어느정도 순서를 보장
    SortedMap을 구현한 NavigableMap을 구현 => 순서를 보장
    key 자료형은 compareTo()를 사용해 중복 체크하기 때문에, 자료형은 Comparable 인터페이스를 구현하거나, Comparator을 입력해줘야 한다
    데이터 접근, 추가, 제거 모두 O(lg N)
    HashMap, LinkedHashMap 보다 속도는 느리지만, 정렬된 상태라는 특징이 존재



    #TreeSet: RB Tree를 사용한 Set
   <https://medium.com/depayse/kotlin-collections-3-set-treeset-hashset-linkedhashset-7efebee12fe2>

    SortedSet 을 구현한 NavigableSet을 구현 => 정렬된 상태
    TreeMap기반으로 동작 
        하나의 dummy 객체를 만들어, 이 객체를 모든 원소의 value로 사용하고, 실제 원소들을 key로 구성
    sortedSetOf() 로 초기화
    compareTo()를 사용해 중복 체크하기 때문에, 자료형은 Comparable 인터페이스를 구현하거나, Comparator을 입력해줘야 한다
    inster, delete, search 가 O(lg N)
    HashSet, LinkedHashSet 보다 전반적으로느리지만, 정렬된 상태라는 특징이 존재


    위의 컬렉션들에서 순서와 관련된 메소드들을 한번 쭉 보고 넘어가자
    ===============================
    C++ 의 STL에서의 bst
    unordered_set, unordered_multiset, unordered_map => 해시
    set, multiset, map => 이전 검색 트리


    =================================
    이진 검색 트리의 연산은 확인한 것 처럼 O(lg N)이 되는건 맞지만 같은 O(lg N)중에서도 상당히 느립니다
    새로운 노드를 동적할당하거나, 편향성을 해소해주기 위해 노드를 떼었다 붙였다 하는 등 연산이 추가로 진행되는 경우가 많기 때문


    연습문제
    :전 단원에 있던 문제들은 당연히 set/map으로도 해결이 가능
    그 외에 대소관계가 잘 설정된다는 특성을 이용할 수 있는 문제 위주로 소개
    
    1. 백준 7662(x)
    C++ 에는 bst로 이루어진 자료구조 set, map, multiset 중 multiset이 중복을 허용해서 multiset를 사용하여 풀이가 가능하지만
    kotlin 은 TreeSet, TreeMap 모두 중복을 허용하지 않아 풀이가 불가능한 것 같다 

    다음 단원 우선순위 큐를 공부하고 다시 풀어보자

*/