/*  
    바킹독님 알고리즘 강의 중 우선순위큐 단원 연습문제
    gold 4

    카드 정렬하기
    https://www.acmicpc.net/problem/1715

    정렬된 두 묶음의 숫자 카드가 존재
    각 묶음의 카드의 수를 A,B라 하면 보통 두 묶음을 합쳐서 하나로 만드는 데에는 A+B번의 비교를 해야 한다
    Merge 하는데는 O(N+M)이 필요하다
    예) 20장 + 30장을 합치려면 50번의 비교가 필요

    매우 많은 숫자 카드 묶음이 책상 위에 놓여 있다
    이들을 두 묶음씩 골라 서로 합쳐나간다면, 고르는 순서에 따라서 비교 횟수가 매우 달라진다
    예)
    [10장, 20장, 40장] 의 묶음이 존재할때
    1.
    10장 + 20장 => 30번의 비교
    30장 + 40장 => 70번의 비교 => 총 100번의 비교

    2.
    10장 + 40장 => 50번의 비교
    50장 + 20장 => 70번의 비교 => 총 120번의 비교

    N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 최소한 몇 번의 비교가 필요한지를 구하는 프로그램 작성

    2초
    1<= N <= 100,000
    숫자 카드 묶음의 크기는 1,000보다 작거나 같은 양의 정수
*/
/*
    명제 - 비교의 수를 최소로 하려면 N,M이 작아야 한다

    [10, 20, 30] 
    10장 + 20장 => 30번의 비교, 30장의 카드 묶음
    30장 + 30장 => 60번의 비교
    30+60 = 90

    10장 + 30장 => 40번의 비교, 40장의 카드 묶음
    40장 + 20장 => 60번의 비교, 60장의 카드 묶음
    40+60 = 100

    [10, 20, 30, 40]
    10장 + 20장 => 30번의 비교, 30장의 카드 묶음
    30장 + 30장 => 60번의 비교, 60장의 카드 묶음
    60장 + 40장 => 100번의 비교, 100장의 카드 묶음
    30+60+100 => 190

    10장 + 30장 => 40번의 비교, 40장의 카드 묶음
    40장 + 20장 => 60번의 비교, 60장의 카드 묶음
    60장 + 40장 => 100번의 비교, 100장의 카드 묶음
    40+60+100 => 200
    
    => 카드의 뭉치가 작은 것 부터 더해 나간다
*/
/*
    그리디 접근
    1. 일단 그럴싸한 방법이 생각나면 구현해본다
    
    #카드 목록에서 가장 작은 2개를 선택해 merge 한다
    merge된 카드 뭉치는 다시 목록에 넣고 mergeCount 기록, 반복한다

    카드 목록에서 가장 작은 뭉치를 선택하는 방법
    1. 우선순위큐 -> offer, pop 둘다 O(lg N)
    2. list에 add 후 정렬 
    -> add and sort => O(N) 이후 O(lg N) 이니 O(N)
    -> get min value and remove => O(N)

    우선순위큐 사용이 시간복잡도가 더 좋다
*/
/*
    제출
    1. 정답
*/
/*
    정답을 맞추고 난 다음 바킹독님의 해설을 확인

    다 합쳐질때까지 매 순간마다 가장 작은 묶음 2개를 하나로 만드는 것을 반복하는 그리디 문제
    해당 그리디 명제가 왜 알맞을까?
    => 정보이른(Information theory)분야의 유명한 알고리즘과 지금 이 문제가 닿아 있다

    허프만 코딩 - 데이터를 효율적으로 압출할 때 사용하는 방법
    zip, rar등 과 같은 파일들을 압축할때 실제로 허프만 코딩이 사용된다

    허프만 코딩의 압축이 지금 이 문제의 그리디 풀이와 완전 똑같은 방식으로 진행
    허프만 코딩이 최적임을 증명하는 과정을 보면 귀납법을 이용
    N=2일때 해당 방법이 최적인건 자명하고, N=k이면 최적이라고 할때, N=k+1에서도 최적임을 보이는 방식으로 증명이 가능

*/

import java.util.PriorityQueue
fun main(args: Array<String>){
    Solution1715().solve()
}
class Solution1715 {
    fun solve(){
        val bw = System.out.bufferedWriter()
        val br = System.`in`.bufferedReader()
    
        val queue = PriorityQueue<Int>() // 기본 최소힙
        repeat(br.readLine().toInt()){
            queue.offer(br.readLine().toInt())
        }

        var mergeCount = 0
        while(queue.size>=2){
            val a = queue.poll()
            val b = queue.poll()
            mergeCount += (a+b)
            queue.offer(a+b)
        }
        bw.write("${mergeCount}\n")

        bw.flush()
        bw.close()
        br.close()
    }
}