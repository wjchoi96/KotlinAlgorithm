/*
    바킹독님 알고리즘 강의 중 이진검색트리, 우선순위큐 단원 문제
    gold 2
    #우선순위 큐 구현
    priorityqueue.1202.kt
    #이진검색트리 구현
    binarysearchtree.1202.kt

    보석 도둑

    도둑이 보석점을 털기로 결심했다
    상덕이가 털 보석점에는 보석이 종 N개 있다
    각 보석은 무게 M[i] 와 가격 V[i]를 가지고 있다
    도둑은 가방K개를 가지고 있고, 각 가방에 담을 수 있는 최대 무게는 C[i]이다
    가방에는 최대 한 개의 보석만 넣을 수 있다
    훔칠 수 있는 보석의 최대 가격을 구하시오

    1초
    1<= N, K <= 300,000
    0<= M[i], V[i] <= 1,000,000
    1<= C[i] <= 100,000,000

*/
/*
    그리디인지 파악하기 힘들었겠는데

    그럴듯한 그리디로 구현해보자

    가방을 오름차순으로 정렬 한 뒤
    현재 가방에 담을 수 있는 보석 중 가장 큰 가치를 지닌 보석을 담는다

    무게가 작은 순으로, 무게가 같다면 가치가 높은 순으로 우선순위 부여
    
    가방 [2, 10]
    보석 [1:65, 2:99, 5:23]

    현재 item이 다음 item 중 가치가 큰 item을 보존, 가치가 작은 item은 제거
    다음 item이 담을 수 없는 무게일때까지 반복하여, 현재 가방에 담을 수 있는 최고의 가치의 물건을 선택

    => 만약 가방에 담을 수 있는 item이 없다면? 가치가 작은 item은 제거해버렸잖아
    예) 
    가방 [2, 2, 3]
    보석 [1:22, 2:44, 3:33]

    첫번째 가방에 2:44가 담길것이며, 1:22는 제거될것
    두번째 가방에 담을 것이 없다

    가치가 작은 item을 제거하는게 아닌 유지시킬 방법을 생각해보자
    -> 보관해 뒀다가 다시 offer => 개당 O(lg N)의 시간복잡도. 최대 N개 
    => 시간복잡도가 안될것 같은데

    ===== 이거도 맞는 방법일 것 같은데, 일단 다른 풀이를 좀 확인해보자 =====
*/
/*
    바킹독님 해설 슬쩍 보려다가 본 그리드 접근법

    가격이 높은 보석순으로 정렬
    현재 보석을 담을 수 있는 가장 작은 베낭에 보석을 담는다

    귀류법1. 
    가장 가격이 높은 보석x를 해당 보석을 담을 수 있는 가방중 최대무게가 A보다 큰 B가방에 담는게 더 이득인가?
    => 만약 A에 다른 보석y가 있다면, 가방 A와 가방B의 내용물 바꿔도 제한 조건에 아무런 문제가 없다

    예) 
    가방 [2, 2, 3]
    보석 [2:44, 3:33, 1:22]
    2:44를 가방[2]에 담는다
    3:33을 가방[3]에 담는다
    1:22를 가방[1]에 담는다

    귀류법1에 대한 반례
    2:44를 가방[3]에 넣는다
    3:33를 담을 가방이 없다
    1:22를 가방[2]에 담는다

    ===== 근데 얘도 구현이... =====
    보석을 가치가 높은 순으로, 가치가 같아면 무게가 작은 순으로 우선순위 부여
    

*/