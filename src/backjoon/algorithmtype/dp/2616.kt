/*
    네이버 카페 문제 50선 중 구간합 유형 문제
    gold 4

    소형기관차
    https://www.acmicpc.net/problem/2616

    기차는 맨 앞에 있는 기관차 1대가 손님이 탄 객차 여러 칸을 끌고 간다
    기관차 고장에 대비하여 몇몇 역에 소형 기관차 3대를 배치하였다. 소형 기관차는 훨씬 적은 수의 객차만을 끌 수 있다
    기관차가 고장나면 끌고 가던 객차 모두를 소형 기관차 3대가 나누어 끌 수 없기 때문에, 소형 기관차들이 어떤 객치들을 끌고 가는 규칙을 정합
    
    1. 소형 기관차가 최대로 끌 수 있는 객차의 수를 미리 정해 놓고, 그보다 많은 수의 객차를 절대로 끌게 하지 않는다
    3대의 소형 기관차가 최대로 끌 수 있는 객차의 수는 서로 같다
    
    2. 소형 기관차 3대를 이용하여 최대한 많은 손님을 목적지까지 운송하도록 한다.
    각 객차마다 타고 있는 손님의 수는 미리 알고 있고, 다른 객차로 손님이 이동할 수 없다

    3. 각 소형기관차는 번호가 연속적으로 이어진 객차를 끌게 한다.
    객차는 기관차 바로 뒤에 있는 객차부터 시작하여 1번 부터 차례로 번호가 붙어 있다
    (1-based index)

    객차의 수, 각 객차에 탄 손님 수, 소형기관차가 최대로 끌 수 있는 객차의 수가 주어질때
    소형기관차 3대를 이용하여 최대로 운송 가능한 손님 수를 구하시오

    1<= 객차의 수 <= 50,000
    1<= 한 객차의 손님 수 <= 100
    소형 기관차가 최대로 끌 수 있는 객차의 수는 기관차가 끌고가던 객차 수의 1/3 보다 작다
    => 소형 기관차 3대가 끌수 있는 만큼 다 끌어도 남는게 있다
*/
/*
    input: [35 40 50 10 30 45 60]

    arr:   [0, 35, 75, 125, 135, 165, 210, 270]
    1-based-index 이라 맨 앞에 arr[0]=0 추가
*/
/*
    1. 누적 합 배열 생성
    2. dp로 구현
    https://comyoung.tistory.com/184
    https://velog.io/@leeinae/Algorithm-%EB%B0%B1%EC%A4%80-2616-%EC%86%8C%ED%98%95%EA%B8%B0%EA%B4%80%EC%B0%A8-java
    https://congsoony.tistory.com/111
    이 위에 링크의 테이블들은 각각 다른데, 점화식들은 모두 같다
    => 근데 테이블들이 모두 이해가 안간다

    공통
    dp 테이블은 다 다른데, 점화식은 같다
    j in i*max..n

    m = 2

    dp -> 1 based index
    1. 테이블 정의하기
    - dp[i][j] = 소형기관차가 i개 있고, 객실이 j번까지 있을 때 운송 가능한 최대 승객 수 
    => https://stillchobo.tistory.com/110 -> 이거는 좀 이해간다

    ===== 소형 기관차가 1개 일때 ======
    dp[1][2] - 쇼형기관차가 1개 있고, 객실이 2번까지 존재
    => 다 끌면 된다
    => arr[2]-arr[2-m] = arr[2]

    dp[1][3] - 소형기관차가 1개 있고, 객실이 3번까지 존재
    => 1-2 or 2-3 중에 최대값을 구해야 한다
    = max(dp[1][2], arr[[3]-arr[3-m]])

    dp[1][4] - 소형기관차가 1개 있고, 객실이 4번까지 존재
    => 1-2 or 2-3 or 3-4 중 최대값을 구해야 한다
    => 1-2 or 2-3 중 최대값은 dp[1][3]
    => max(dp[1][3], arr[4]-arr[4-m])

    :dp[1][j] = max(dp[1][j-1], arr[j]-arr[j-m])
    => j번째 객실을 운송하는것이 최대일지, 이전객실 운행정보를 유지하는게 최대일지 찾는다
   
    ==== 소형 기관차가 2개 일때 =======
    dp[2][4] - 소형기관차가 2개있고, 객실이 4번까지 존재
    => 1-2 3-4 경우의 수 뿐
    dp[1][2] + arr[4]-arr[4-m:2]

    dp[2][5] - 소형기관차가 2개있고, 객실이 5번까지 존재
    => [1-2, 3-4] or [2-3, 4-5] or [1-2, 4-5] 의 경우의 수

    : 새로 추가된 j칸을 반드시 끄는 경우의 점화식
    => [1-2, 4-5] or [2-3, 4-5]
    위의 점화식대로 dp[1][3] + arr[5]-arr[5-2:3] 
    => (1-2 or 2-3) + (4-5) 
   
    : 새로 추가된 화물을 끌지 않는 경우의 점화식
    => [1-2, 3-4] 의 경우의 수
    => dp[2][4]

    === 총 점화식 ===
    dp[i][j] = max(
        dp[i-1][j-1], // 새로 추가된 j화물을 끌지 않는 경우의 수
        dp[i-1][j-m] + (arr[j]-arr[j-m]) // 새로 추가된 j화물을 반드시 끄는 경우의 수
    )

    2. 점화식 찾기
    j는 i*m..n => 소형 기관차가 최대로 끌 수 있는 객차의 수는 기관차가 끌고 가던 객차 수의 1/m보다 적다.
    dp[i][j] = max(
        dp[i-1][j-1], // 새로 추가된 j화물을 끌지 않는 경우의 수
        dp[i-1][j-m] + (arr[j]-arr[j-m]) // 새로 추가된 j화물을 반드시 끄는 경우의 수
    )

    3. 초기값 설정
    1-based-index 이니 0index 들을 모두 0으로 초기화 => 그냥 모두 0으로 초기화 해도 된다
    => max 로 값이 결정되기때문에 -1 이든 0 이든 상관없을듯
*/
/*
    제출
    1. 맞았습니다
    - 맞았지만, 정답을 보고도 테이블이 정의가 한참 이해가 안갔던 문제였다
*/
fun main(args: Array<String>){
    Solution2616().solve()
}
class Solution2616 {
    fun solve(){
        val bw = System.out.bufferedWriter()
        val br = System.`in`.bufferedReader()

        val n = br.readLine().toInt()
        val arr = Array(n+1){0}
        br.readLine().split(' ').map{it.toInt()}.forEachIndexed{i,v ->
            arr[i+1] = arr[i]+v
        }
        val m = br.readLine().toInt()
        var dp: Array<Array<Int>> = Array(4){Array(n+1){0}}

        for(i in 1..3){
            for(j in (i*m)..n){
                dp[i][j] = Math.max(
                    dp[i][j-1], 
                    arr[j]-arr[j-m] + dp[i-1][j-m]
                )
            }
        }
        bw.write("${dp[3][n]}\n")
    
        bw.flush()
        bw.close()
        br.close()
    }
}