/*
    바킹독님 알고리즘 강의 중 연결리스트 단원

    단원을 다 끝내면
    2021 카카오 인턴 코테 기출문제 3번 표편집 문제를 연결리스트 방식을 적용해서 풀어보자
    https://programmers.co.kr/learn/courses/30/lessons/81303

    연결리스트
    - 원소를 저장할때, 현재 원소가 다음 위치에 있는 원소를 기억하는 방식의 자료구조
        => 내가 알기론, 다음위치뿐 아니라 이전 위치의 원소도 기억하는것으로 알고있다 => 이중 연결리스트

    
    시간복잡도
    - k번째 원소를 확인, 변경하기 위해 O(k)가 필요
        => [k]를 찾기위해 0번째 원소부터 확인해들어가야 하기 때문
    - 임의의 위치에 원소를 추가, 제거는 O(1)
    - 원소들이 메모리상에 연속해있지 않아서 Cache hit rate 가 낮지만 할당이 다소 쉬움

    cache hit ratio : 적중률 = (캐시히트횟수)/(전체 참조횟수)
    cache hit : 참조하려는 데이터가 캐시에 존재할때 캐시 히트
    cache miss : 참조하려는 데이터가 캐시에 존재하지 않을때 캐시 미스


    종류
    - 단일 연결리스트
        => 각 원소가 자기 다음 원소의 주소를 기억
    - 이중 연결 리스트
        => 각 원소가 자기 이전, 다음 원소의 주소를 기억
        => 각 원소가 가지는 정보가 1개 더 늘어서 메모리를 더 쓴다는 단점이 존재
    - 원형 연결리스트
        => 끝과 처음이 연결되어있다
    
    
    배열과 연결리스트는 메모리상에 원소를 놓는 법이 다르지만, 원소들 사이의 선후 관계가 일대일로 정의가 된다
    선형 자료구조라고 불린다

    트리, 그래프, 해쉬 등은 비선형 자료구조의 대표

    배열 vs 연결리스트
    - 원소의 접근
        => 배열 : O(1)
        => 연결리스트 : O(n)
    - 임의 위치에 원소를 추가, 제거
        => 배열 : O(n) / 다만 끝자리 추가, 제거는 O(1)
        => 연결리스트 : O(1)

    - 메모리 상의 배치
        => 배열 : 연속
        => 연결리스트 : 불연속
    
    - 추가적으로 필요한 공간(Overhead)
        => 배열 : 저장공간이 정해져있어서 필요없다. 굳이 따지자면 길이를 저장할 int 1개
        => 연결리스트 : 각 원소가 다음원소, 혹은 이전원소의 주소값까지 지니고 있어야한다.
            => 32비트 컴퓨터면 32비트(4바이트)단위이니 4N바이트, 64비트 컴퓨터면 64비트(8바이트)단위이니 8N바이트가 추가로 필요
            => N에 비례하는만큼 메모리를 추가적으로 사용
    
    구현
    implements.kt 
    => 이중 연결리스트 구현
    => 간단한 테스트 결과 구현 잘 된것같다
    
    바킹독님이 소개해준 야매 연결리스트는 간단히 읽어만 보고 넘어갔다

    
    연습문제
    1. 백준 1406

    
*/