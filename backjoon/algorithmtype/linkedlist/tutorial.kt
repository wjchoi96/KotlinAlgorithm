/*
    바킹독님 알고리즘 강의 중 연결리스트 단원

    단원을 다 끝내면
    2021 카카오 인턴 코테 기출문제 3번 표편집 문제를 연결리스트 방식을 적용해서 풀어보자
    https://programmers.co.kr/learn/courses/30/lessons/81303

    연결리스트
    - 원소를 저장할때, 현재 원소가 다음 위치에 있는 원소를 기억하는 방식의 자료구조
        => 내가 알기론, 다음위치뿐 아니라 이전 위치의 원소도 기억하는것으로 알고있다 => 이중 연결리스트

    
    시간복잡도
    - k번째 원소를 확인, 변경하기 위해 O(k)가 필요
        => [k]를 찾기위해 0번째 원소부터 확인해들어가야 하기 때문
    - 임의의 위치에 원소를 추가, 제거는 O(1)
    - 원소들이 메모리상에 연속해있지 않아서 Cache hit rate 가 낮지만 할당이 다소 쉬움

    cache hit ratio : 적중률 = (캐시히트횟수)/(전체 참조횟수)
    cache hit : 참조하려는 데이터가 캐시에 존재할때 캐시 히트
    cache miss : 참조하려는 데이터가 캐시에 존재하지 않을때 캐시 미스


    종류
    - 단일 연결리스트
        => 각 원소가 자기 다음 원소의 주소를 기억
    - 이중 연결 리스트
        => 각 원소가 자기 이전, 다음 원소의 주소를 기억
        => 각 원소가 가지는 정보가 1개 더 늘어서 메모리를 더 쓴다는 단점이 존재
    - 원형 연결리스트
        => 끝과 처음이 연결되어있다
    
    
    배열과 연결리스트는 메모리상에 원소를 놓는 법이 다르지만, 원소들 사이의 선후 관계가 일대일로 정의가 된다
    선형 자료구조라고 불린다

    트리, 그래프, 해쉬 등은 비선형 자료구조의 대표

    배열 vs 연결리스트
    - 원소의 접근
        => 배열 : O(1)
        => 연결리스트 : O(n)
    - 임의 위치에 원소를 추가, 제거
        => 배열 : O(n) / 다만 끝자리 추가, 제거는 O(1)
        => 연결리스트 : O(1)

    - 메모리 상의 배치
        => 배열 : 연속
        => 연결리스트 : 불연속
    
    - 추가적으로 필요한 공간(Overhead)
        => 배열 : 저장공간이 정해져있어서 필요없다. 굳이 따지자면 길이를 저장할 int 1개
        => 연결리스트 : 각 원소가 다음원소, 혹은 이전원소의 주소값까지 지니고 있어야한다.
            => 32비트 컴퓨터면 32비트(4바이트)단위이니 4N바이트, 64비트 컴퓨터면 64비트(8바이트)단위이니 8N바이트가 추가로 필요
            => N에 비례하는만큼 메모리를 추가적으로 사용
    
    구현
    implements.kt 
    => 이중 연결리스트 구현
    => 간단한 테스트 결과 구현 잘 된것같다
    
    바킹독님이 소개해준 야매 연결리스트는 간단히 읽어만 보고 넘어갔다

    
    연습문제
    1. 백준 1406(solve)
    - 기본적인 linkedList 를 사용하면 시간초과가 발생한다
    => addAt, removeAt 이 O(n) 연산이기 때문
    => 해결하기 위해서는 현재 커서가 가리키고있는 node의 정보를 기억해야한다
    => 이를 위해서는 기본 LinkedList + listIterator 를 사용하거나
    => cursor정보를 가지고있는 linkedList 를 구현해야한다
    => 추가로 stack 2개를 사용하는 방법도 존재한다고 한다

    => ListIterator 사용해서 진행하는 방식은 꼭 다시 풀어볼것
    => Stack 사용해서 진행하는 방식은 Stack 단원 공부 후 구현해볼것

    # 여기서부터는 단일 연결리스트 기준의 문제들

    2. 원형 연결리스트 내의 임의의 노드 하나가 주어졌을때, 해당 List의 길이를 효율적으로 구하는 방법?(손코딩, 면접 질문 예상)
    -> 걍 순회하는 방법밖에 없지않나? 자기 자신을 만날때까지 순회 
    => 정답
    : 시간복잡도 O(n), 공간복잡도 O(1)

    3. 중간에 만나는 두 연결리스트의 시작점들이 주어졌을때, 만나는 지점을 구하는 방법?(손코딩, 면접 질문 예상)
    -> 이건 잘 모르겠네..
    => 1. 각 list 를 끝까지 진행해서 size를 각각 구함
    => 2. 두 size의 차를 구해 더 긴쪽을 size의 차만큼 먼저 이동시키고, 두 시작점이 만날때까지 동시에 한 노드씩 방문
    : 시간복잡도 O(A+B), 공간복잡도 O(1)

    4. 주어진 연결리스트 안에 사이클이 있는지 판단하라(앞의 노드가 list의 이전 노드 중 하나를 가리켜서 순환이 이루어지고있는지 여부) (손코딩, 면접 질문 예상)
    -> list를 순환하다가 한번 순환했던 node를 만난다면? => 이건 공간복잡도가O(n)인 방법일텐데, O(1)인 방법이 있다고 한다
    -> list를 하나 순회시작하고, 다른 list가 따라서 순회를 시작?
    정답
    : Floyd's cycle-finding algorithm 
    => 한칸씩 가는 커서와, 두칸씩 가는 커서를 동일한 시작점에서 출발
    => 사이클이 있는 경우 두 커서는 반드시 만나게 된다
    => 없다면 만나지못하고 끝에 도달
    : 시간복잡도O(n), 공간복잡도 O(1)

    5. 카카오 2021 인턴 기출문제 3번 표 편집
    https://programmers.co.kr/learn/courses/30/lessons/81303
    => 연결리스트로 구현해보자
    => 구현해보기 전에 ListIterator로 1번문제 다시 구현해보고 진행해보자
    
*/