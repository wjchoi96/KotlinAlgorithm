/*
    바킹독님 알고리즘 강의 중 정렬 단원
    https://blog.encrypted.gg/955

    QuickSort
    : 거의 모든 정렬알고리즘보다 빠른 정렬 알고리즘
    : 라이브러리의 정렬은 대부분 퀵소트로 바탕으로 이루어져있다
    !!다만, 코딩테스트에서 정렬을 구현할일이 있다면 퀵소트는 절대 사용하지말고, 머지소트를 구현해서 사용할것
    - 퀵소트는 최악의 경우 o(n^2)이 될 가능성이 있기때문.
    => 라이브러리에서는 이를 방지하기 위한 코드가 추가되어있다

    구현
    quicksorttut.kt 파일
    1. 매 단계마다 pivot이라고 이름 붙인 원소 하나를 제자리로 보내는 작업을 반복
    : pivot보다 작은 원소는 pivot앞으로, 큰원소는 뒤로 배치시키는 작업
    2. pivot을 제자리로 보내고나면, pivot을 제외하고 왼쪽, 오른쪽으로 나누어서 해당 작업을 또 반복한다
    => 재귀적으로 반복
    => 각 나눠진 리스트에서 똑같이 반복하고, 리스트 크기가 1이하가 되면 base condition에 도달한다 (base condition: 순환을 멈추는 구간)

    3. pivot을 제자리로 보내는 방법
    => 단순히 접근하면 추가적인 배열을 생성하여, 배열을 한번 순회하여 pivot보다 작은 원소를 먼저 넣고, pivot을 넣고, 나머지를 넣으면 된다
    => 퀵소트의 장점은 추가적인 공간이 필요하지 않다는것인데, 이렇게 구현하면 해당 장점이 퇴색되는것
    => 배열안에서의 자리바꿈만으로 처리되기때문에 cache hit rate 가 높지않아서 속도가 빠르다
    : 추가적인 공간을 사용하지 않는 정렬을 In-Place-Sort 라고 한다
    #cache hit rate 이란?
    : 캐시 히트율, 캐시 히트율 이란, 캐시된 데이터를 요청할 때 해당 키 값이 메모리에 존재하여 얼마만큼의 비율로 잘 찾았는지에 대한 여부를 말합니다
    : 이게 여기서 의미하는게 맞나?

    4.  추가적인 공간을 사용하지 않고 pivot을 제자리로 보내는 방법
    => left, right 라는 포인터를 양 끝에 둔다
    => left는 pivot보다 큰값이 나올때까지 오른쪽으로 이동, right는 pivot보다 작은값이 나올때까지 왼쪽으로 이동
    => 두 포인터가 가리키는 값을 swap
    => left, rigth가 교차할때까지 반복, 교차한다면 pivot과 right를 교체한다

    #시간복잡도
    1. pivot을 기준으로 양쪽으로 나눠지는데 o(n)
    2. 나눠진 반쪽들이 각각 pivot을 기준으로 양쪽으로 나눠지는작업을 다 합쳐서 o(n)
    3. 1,2 번과 같은 작업들이 pivot이 매번 완벽하게 중앙에 위치해서 리스트를 균등하게 쪼갠다면 단계의 개수는 머지소트와 같이 lg n 이될것
    => o(nlgn)
    # 매번 pivot이 정중앙에 위치하지는 않겠지만 매번 어느정도로만 잘 자리잡는다면 o(nlgn)이 보장된다
    # cache hit rate가 높다는 점 때문에 퀵소트는 속도가 굉장히 빠르다
    !! 다만 앞서 언급했지만 최악의 경우는 o(n^2)가 된다.

    직접 구현 주의점
    # 코딩테스트 등에서 직접 구현을 할경우 퀵소트는 사용하지말고, 머지소트 추천
    # 머지소트가 퀵소트보단 느리지만, o(nlgn)이라 충분히 빠르다.

    라이브러리에서의 퀵소트
    1. 피벗을 랜덤하게 택하는 방법
    2. 피벗 후보를 3개를 정해, 그 3개중에서 중앙값을 피벗으로 택한다
    3. 최악의 경우에도 O(nlgn)을 보장하기 위해 일정 깊이 이상 들어가면 퀵소트 대신 o(nlgn)이 보장되는 힙 소트로 정렬
    => 이러한 정렬을 introspective sort 라고 한다.


    */