/*
    Radix Sort(라딕스 소트, 기수정렬)

    기수정렬이 가능한 이유?
    - A, B의 위치관계를 생각하면, A>B라면 언젠간 높은 자리수에서는 A의 자리수가 B의 자리수보다 큰 경우가 발생할것

    시간복잡도
    - Radix sort는 자릿수의 최대 개수가 D개라고 할때, D번에 걸쳐 카운팅 소트를 하는것과 같다
    - 리스트의 개수K일때, O(D(N+K))이지만, 보통 리스트의 개수는 N에 비해 무시가 가능할정도로 작다
    - 아래 예시의 경우도 리스트의 개수K가 10개뿐
    - 결론적으로 O(DN)

    구현
    : radixsort.kt

    Comparison Sort
    - 버블소트
    - 머지소트
    - 퀵소트

    Non-Comparison Sort
    - 카운팅 소트
    - 라딕스 소트

    버블, 머지, 퀵 소트는 원소들끼리 크기를 비교하는 과정이 존재
    카운팅, 라딕스 소트는 원소들간의 크기를 비교하지 않고 정렬을 수행

*/

/*
    예)
    [012, 421, 046, 674, 103, 502, 007, 100, 021, 545]
    10개의 수, 10개의 리스트(0~9번 리스트)

    #1. 각 수의 1의자리에 따라 n번 list에 수를 넣는다
    0: [100]
    1: [421, 021]
    2: [012, 502]
    3: [103]
    4: [674]
    5: [545]
    6: [046]
    7: [007]
    8: []
    9: []

    #1-1. 이후 0번 리스트부터 수를 꺼내서 수열을 재배열 
    [100, 421, 021, 012, 502, 103, 674, 545, 046, 007]

    이러면 1의 자리를 기준으로 정렬의 되어있다
    1의 자리가 같은 수들끼리는, 처음 정렬의 순서 그대로 배치된다

    #2. 1의 자리를 기준으로 정렬된 리스트를 10의 자리로 정렬
    0: [100, 502, 103, 007]
    1: [012]
    2: [421, 021]
    3: []
    4: [545, 046]
    5: []
    6: []
    7: [674]
    8: []
    9: []
    #2-1. 똑같이 0번 리스트부터 수를 꺼내서 수열을 재배열
    [100, 502, 103, 007, 012, 421, 021, 545, 046, 674]

    #3. 1, 10의 자리를 기준으로 정렬된 리스트를 100의 자리로 정렬
    0: [007, 012, 021, 046]
    1: [100, 103]
    2: []
    3: []
    4: [421]
    5: [502, 546]
    6: [674]
    7: []
    8: []
    9: []
    #3-1. 똑같이 0번 리스트부터 수를 꺼내서 수를 재배열
    [007, 012, 021, 046, 100, 103, 421, 502, 546, 674]
    # 정렬 완료
*/