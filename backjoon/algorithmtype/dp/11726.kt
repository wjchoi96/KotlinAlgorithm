/*
    바킹독님 알고리즘 강의 중 dp단원 연습문제
    sliver 3
    https://www.acmicpc.net/problem/11726

    2*n 타일링
    : dp단원 연습문제가 아니였다면 dp문제라고 인지하기 힘들었을것 이라고 말씀하셨다
    : 테이블까지 제시해 주신다 하셨지만, 혼자서 접근해보자

    2*n 크기의 직사각형을  1*2, 2*1 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오

    첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.

    1< n <= 1000
*/
/*
    1. 테이블 정의하기
    - dp[n]: 2*n 테이블을 1*2, 2*1로 채우는 방법의 수
    
    2. 점화식 찾기
    dp[1] = 1 
    - (2*1) 
    dp[2] = 2
    - (2*1 2개) (1*2 2개)
    dp[3] = 3
    - (2*1 3개), (2*1 1개, 1*2 2개)(2가지)
    : (2*1 1개, 1*2 2개)의 경우는 조합에 따라 2가지가 나올 수 있는데 그걸 개별의 경우의 수로 측정하는건가?
    : 아마 별개로 할것 같다

    dp[4] = 5
    - (2*1 4개), (2*1 2개, 1*2 2개)(3가지), (1*2 4개)

    dp[5] = 


    2*n 이 몇개의 2*[n이하]의 사각형들로 조합될 수 있는지 체크
    => 짝수는 2*n/2 가 2개
    !! 짝수도 동일하게 2*n-1, 2*1 의 조합으로 나타낸다
    => 홀수는 2*n-1, 2*1 의 조합

    홀수일때와 짝수일때의 처리만 찾으면 된다
    dp[3] 구하기 예) 2*3 은 2*1, 2*2의 조합
    => dp[2]와 dp[1]을 이용해서 알아낼 수 있지 않을까?
    : 2*3을 2*1과 2*2로 나타내는 경우의 수는 2가지이다
    : 그런데 2*2를 나타내는 경우의 수는 2가지이다 (dp[2])
    : 2*2 = 4가지
    !!그런데 2*1이 연속으로 늘어져 있는 경우는 모두 동일한 경우이기때문에 -1
    !!근데 이 계산법이 dp[n-1]*2 -1 이 아니라 (dp[n-1]-1)*2 가 되어야 할듯
    => dp[3] = 3

    dp[4] 구하기 예) 2*4 는 2*2 2개의 조합
    => 이 아니라 dp[3]과 dp[1]의 조합으로 하는게 더 편할듯
    => dp[2] 를 이용해서 알아낼 수 있지 않을까?
    => 2*4 를 2*3과 2*1로 나타낼 수 있는 경우의 수는 2가지
    => 2*3을 나타낼 수 있는 경우의 수는 3
    => 2*3-1 = 5
    => dp[4] = 5

    점화식 추측
    dp[n] = dp[n-1]-1 * 2

    변경
    dp[n] = (dp[n-1]-1)*2 로 변경
    : 이유는 2*1 로만 이루어진 경우의 수들이 모두 하나로 취급받기 때문
    : 근데 이건 dp[4] 부터 틀린거였다
    : 짝수는 /2 2개로 계산하는게 맞는거 같은데..
    
    추측대로 진행: dp[n] = dp[n-1]-1 * 2
    dp[5] = 9
    dp[6] = 17
    dp[7] = 33
    dp[8] = 65
    dp[9] = 129 인데... 정답은 dp[9] = 55
    어디서 틀린걸까

    대충 느낌대로 짝수는 /2를 이용, 홀수는 -1 을 이용
    dp[4] = 5
    dp[5] = 9
    dp[6] = 12
    dp[7] = 26
    dp[8] = 30
    dp[9] = 60
    이게 얼추 맞는거 같은데

    3. 초기값 정하기
*/
/*
    점화식 고민

    1. 짝수는 n/2 2개의 조합, 홀수는 n-1, 1 의 조합

    2. n의 조합을 찾는것
    예) 4는 [1,3],[2,2],[3,1] 로 나타낼 수 있다
    예) 5는 [1,4],[2,3],[3,2],[4,1] 로 나타낼 수 있다
*/